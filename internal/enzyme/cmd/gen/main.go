// Code-gen utility for radigest: convert enzymes.json → enzymes_generated.go
//
// Run automatically via
//   go generate ./internal/enzyme/...
//
// You can also run it by hand:
//   go run ./internal/enzyme/cmd/gen -in internal/enzyme/enzymes.json
//
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strings"
	"text/template"
)

type rec struct {
	Name string `json:"name"` // required
	Site string `json:"site"` // recognition site, caret marks cut
	Cut  int    `json:"cut"`  // optional; 0 ⇒ derive from caret
}

var tpl = template.Must(template.New("").Parse(`// Code generated by go:generate; DO NOT EDIT.
package enzyme

var DB = map[string]Enzyme{
{{- range . }}
	"{{ .Name }}": {Name: "{{ .Name }}", Recognition: "{{ .Site }}", CutIndex: {{ .Cut }}},
{{- end }}
}
`))

func main() {
	in  := flag.String("in",  "internal/enzyme/enzymes.json", "input JSON")
	out := flag.String("out", "internal/enzyme/enzymes_generated.go", "output .go file")
	flag.Parse()

	raw, err := os.ReadFile(*in)
	check(err)

	var rs []rec
	check(json.Unmarshal(raw, &rs))

	// --- auto-fill Cut when zero -------------------------------------------
	for i := range rs {
		if rs[i].Cut != 0 {
			continue
		}
		if idx := strings.IndexByte(rs[i].Site, '^'); idx >= 0 {
			rs[i].Cut = idx
		} else {
			rs[i].Cut = len(rs[i].Site) / 2 // safe fallback
		}
	}

	f, err := os.Create(*out)
	check(err)
	defer f.Close()

	check(tpl.Execute(f, rs))
	fmt.Printf("generated %s with %d enzymes\n", *out, len(rs))
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}
